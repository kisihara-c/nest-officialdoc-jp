---
title: techniques-queues
---

## キュー

キューはアプリケーションのスケーリングやパフォーマンスに関する一般的な問題に対処する為、役立つ強力なデザインパターンだ。キューを使って解決可能な問題の例をいくつか挙げてみよう。

- 処理のピークをスムーズにする。例えば、ユーザがリソースを必要とするタスクを任意の時間に開始できる場合、これらのタスクを同時的に実行するのではなく、キューに追加する事ができる。そして、制御された方法で、ワーカープロセスにキューからタスクを引き出させる事ができる。アプリケーションのスケールアップに合わせて、新しいキューの解消者を追加し、バックエンドのタスク処理を拡張する事も簡単だ。
- Node.jsのイベントループをブロックしてしまうような一枚岩のタスクを分割する。例えば、ユーザのリクエストがオーディオnのトランスコーディングのようなCPU負荷の高い作業を必要とする場合、このタスクを他のプロセスに委ねることができ、ユーザに接するプロセスを解放して応答性を維持することができる。
- 様々なサービス間で信頼性の高い通信チャネルを提供する。例えば、あるプロセスやサービスでタスク（ジョブ）をキューに入れ、別のプロセスやサービスでそれを消費する事ができる。ジョブのライフサイクルに置いて、完了、エラー、その他の状態変化が合った場合には、どのプロセスやサービスからでも（ステータスイベントをlistenする事で）通知を受ける事ができる。キューのプロデューサーやコンシューマーに障害が発生しても、状態は保持されて、nodeの再起動時にタスク処理を自動的に再開できる。

Nestは人気があってしっかりサポートされている、高性能なNode.jsベースのキューシステム実装　[Bull](https://github.com/OptimalBits/bull)の抽象化/ラッパーとして`@nestjs/bull`パッケージを提供している。このパッケージを使えば、Nestフレンドリーな方法でBull Queuesをアプリケーションに簡単に統合できる。

Bullはジョブデータの永続化に[Redis](https://redis.io/)を使用している為、システムにRedisがインストールされている必要がある。Redisに支えられている事で、Queueのアーキテクチャは完全に分散されてプラットフォームに依存しない。例えば、一部のキューのプロデューサーとコンシューマー、リスナーを一つ（または複数）のノード上のNestで待機させ、他のそれぞれを他のネットワークノード上の他のNode.jsプラットフォームで動作させられる。

本章では`@nestjs/bull`パッケージを説明する。背景や具体的な実装の詳細については[Bullのドキュメント](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md)の参照を勧める。

## インストール

パッケージを使い始める為、まず依存関係をインストールしよう。

```
$ npm install --save @nestjs/bull bull
$ npm install --save-dev @types/bull
```

インストールが終わったら、ルートの`AppModule`に`BullModule`をインポートしよう。

```ts :app.module.ts 
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';

@Module({
  imports: [
    BullModule.forRoot({
      redis: {
        host: 'localhost',
        port: 6379,
      },
    }),
  ],
})
export class AppModule {}
```